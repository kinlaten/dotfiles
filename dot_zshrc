
#copy history using fzf
alias hisc='history -n -1000|tac|fzf|clip'

alias apt='sudo apt '
alias backup-paperless='docker exec -t paperless-db-1 pg_dump -Fc -U postgres paperless > paperless_db_backup_$(date -Idate).bak'
alias m='man'
alias df='df -h'
alias gitrepo='cd ~/Documents/gitRepo/'
#alias npm='pnpm'
#alias y='yazi'
alias cp='cp -rv '
alias gemflash='gemini --model gemini-2.5-flash'
alias lg='lazygit'
alias gs='git status'
alias lyric='vi ~/Lyrics.md'
alias hi='history -n 30'
alias gt='gnome-terminal'
alias keymap='vi /usr/share/X11/xkb/rules/base.lst'
alias emacs="emacsclient -c -a 'emacs'"
alias vpnui='/opt/cisco/secureclient/bin/vpnui'
alias pgadmin4='~/pgadmin4/bin/pgadmin4'
#alias psql='psql-17'
alias suspend='sudo systemctl suspend'
alias brave='brave-browser'
alias wl-record='wf-recorder -a --file=/home/zen/Videos/"$(date)".mp4 -g "$(slurp)"'
alias al='nohup alacritty 2>&1 > /dev/null &'
alias uowvpn='nohup /opt/cisco/secureclient/bin/vpnui &'
alias docker='sudo docker'
alias monitorconfig='vi ~/.zen_scripts/swaymonitor'
alias doc='cd ~/Documents/ ; l'
alias vi='nvim'
alias py='/usr/bin/python3'
alias ytm='yt-dlp -f 140 '
alias mi='micro'
alias i3config='nvim ~/.config/i3/config'
alias swayconfig='nvim ~/.config/sway/config'
alias n='nnn'
alias sudo='sudo '
alias la='lsd -latr --group-dirs first'
alias l='lsd -tr --group-dirs first -F'
alias run-httpserver='nohup python3 -m http.server 8080 -d'
alias newghrepo="zsh /home/zen/Documents/newGhRepo.sh"
alias free="free -h"
alias dlmusic='yt-dlp --cookies-from-browser brave'
alias find='sudo find 2>/dev/null'
alias play='function _play() {mpv * --no-audio-display -no-resume-playback --playlist-start=$(( $1 - 1 ))}; _play'
alias config='cd ~/.config/'
alias path='echo -e ${PATH//:/\\n}'
#alias zshrc='vi ~/.local/share/chezmoi/dot_zshrc'
alias zshrc='vi ~/.zshrc'
alias laptopscreenon='swaymsg output eDP-1 enable'
alias laptopscreenoff='swaymsg output eDP-1 disable'
alias dow='cd ~/Downloads/; l'
alias clip='xclip -sel clip'


alias dict='function _dict() { dict "$@" | less; }; _dict'


# Personal Zsh configuration file. It is strongly recommended to keep all
# shell customization and configuration (including exported environment
# variables such as PATH) in this file or in files sourced from it.
#
# Documentation: https://github.com/romkatv/zsh4humans/blob/v5/README.md.

# Periodic auto-update on Zsh startup: 'ask' or 'no'.
# You can manually run `z4h update` to update everything.
zstyle ':z4h:' auto-update      'no'
# Ask whether to auto-update this often; has no effect if auto-update is 'no'.
zstyle ':z4h:' auto-update-days '28'

# Keyboard type: 'mac' or 'pc'.
zstyle ':z4h:bindkey' keyboard  'pc'

# Don't start tmux.
zstyle ':z4h:' start-tmux       yes

# Mark up shell's output with semantic information.
zstyle ':z4h:' term-shell-integration 'yes'

# Right-arrow key accepts one character ('partial-accept') from
# command autosuggestions or the whole thing ('accept')?
zstyle ':z4h:autosuggestions' forward-char 'accept'

# Recursively traverse directories when TAB-completing files.
zstyle ':z4h:fzf-complete' recurse-dirs 'no'

# Enable direnv to automatically source .envrc files.
zstyle ':z4h:direnv'         enable 'no'
# Show "loading" and "unloading" notifications from direnv.
zstyle ':z4h:direnv:success' notify 'yes'

# Enable ('yes') or disable ('no') automatic teleportation of z4h over
# SSH when connecting to these hosts.
zstyle ':z4h:ssh:example-hostname1'   enable 'yes'
zstyle ':z4h:ssh:*.example-hostname2' enable 'no'
# The default value if none of the overrides above match the hostname.
zstyle ':z4h:ssh:*'                   enable 'no'

# Send these files over to the remote host when connecting over SSH to the
# enabled hosts.
zstyle ':z4h:ssh:*' send-extra-files '~/.nanorc' '~/.env.zsh'

# Clone additional Git repositories from GitHub.
#
# This doesn't do anything apart from cloning the repository and keeping it
# up-to-date. Cloned files can be used after `z4h init`. This is just an
# example. If you don't plan to use Oh My Zsh, delete this line.
z4h install ohmyzsh/ohmyzsh || return

# Install or update core components (fzf, zsh-autosuggestions, etc.) and
# initialize Zsh. After this point console I/O is unavailable until Zsh
# is fully initialized. Everything that requires user interaction or can
# perform network I/O must be done above. Everything else is best done below.
z4h init || return

# Extend PATH.
#path=(~/bin $path)
#path=(~/.zen_scripts/ $path)


# Export environment variables.
export GPG_TTY=$TTY

# Source additional local files if they exist.
z4h source ~/.env.zsh

# Use additional Git repositories pulled in with `z4h install`.
#
# This is just an example that you should delete. It does nothing useful.
z4h source ohmyzsh/ohmyzsh/lib/diagnostics.zsh  # source an individual file
z4h load   ohmyzsh/ohmyzsh/plugins/emoji-clock  # load a plugin

# Define key bindings.
z4h bindkey z4h-backward-kill-word  Ctrl+Backspace     Ctrl+H
z4h bindkey z4h-backward-kill-zword Ctrl+Alt+Backspace

z4h bindkey undo Ctrl+/ Shift+Tab  # undo the last command line change
z4h bindkey redo Alt+/             # redo the last undone command line change

z4h bindkey z4h-cd-back    Alt+Left   # cd into the previous directory
z4h bindkey z4h-cd-forward Alt+Right  # cd into the next directory
z4h bindkey z4h-cd-up      Alt+Up     # cd into the parent directory
z4h bindkey z4h-cd-down    Alt+Down   # cd into a child directory

# Autoload functions.
autoload -Uz zmv

# Define functions and completions.
function md() { [[ $# == 1 ]] && mkdir -p -- "$1" && cd -- "$1" }
compdef _directories md

# Define named directories: ~w <=> Windows home directory on WSL.
[[ -z $z4h_win_home ]] || hash -d w=$z4h_win_home

# Define aliases.
alias tree='tree -a -I .git'

# Add flags to existing aliases.
alias ls="${aliases[ls]:-ls} -A"

# Set shell options: http://zsh.sourceforge.net/Doc/Release/Options.html.
setopt glob_dots     # no special treatment for file names with a leading dot
setopt no_auto_menu  # require an extra TAB press to open the completion menu

#eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

# Task Master aliases added on 23/09/2025
alias tm='task-master'
alias taskmaster='task-master'

# =============================================================================
#
# Utility functions for zoxide.
#

# pwd based on the value of _ZO_RESOLVE_SYMLINKS.
function __zoxide_pwd() {
    \builtin pwd -L
}

# cd + custom logic based on the value of _ZO_ECHO.
function __zoxide_cd() {
    # shellcheck disable=SC2164
    \builtin cd -- "$@"
}

# =============================================================================
#
# Hook configuration for zoxide.
#

# Hook to add new entries to the database.
function __zoxide_hook() {
    # shellcheck disable=SC2312
    \command zoxide add -- "$(__zoxide_pwd)"
}

# Initialize hook.
# shellcheck disable=SC2154
if [[ ${precmd_functions[(Ie)__zoxide_hook]:-} -eq 0 ]] && [[ ${chpwd_functions[(Ie)__zoxide_hook]:-} -eq 0 ]]; then
    chpwd_functions+=(__zoxide_hook)
fi

# =============================================================================
#
# When using zoxide with --no-cmd, alias these internal functions as desired.
#

__zoxide_z_prefix='z#'

# Jump to a directory using only keywords.
function __zoxide_z() {
    # shellcheck disable=SC2199
    if [[ "$#" -eq 0 ]]; then
        __zoxide_cd ~
    elif [[ "$#" -eq 1 ]] && { [[ -d "$1" ]] || [[ "$1" = '-' ]] || [[ "$1" =~ ^[-+][0-9]$ ]]; }; then
        __zoxide_cd "$1"
    elif [[ "$@[-1]" == "${__zoxide_z_prefix}"?* ]]; then
        # shellcheck disable=SC2124
        \builtin local result="${@[-1]}"
        __zoxide_cd "${result:${#__zoxide_z_prefix}}"
    else
        \builtin local result
        # shellcheck disable=SC2312
        result="$(\command zoxide query --exclude "$(__zoxide_pwd)" -- "$@")" &&
            __zoxide_cd "${result}"
    fi
}

# Jump to a directory using interactive search.
function __zoxide_zi() {
    \builtin local result
    result="$(\command zoxide query --interactive -- "$@")" && __zoxide_cd "${result}"
}

# Completions.
if [[ -o zle ]]; then
    function __zoxide_z_complete() {
        # Only show completions when the cursor is at the end of the line.
        # shellcheck disable=SC2154
        [[ "${#words[@]}" -eq "${CURRENT}" ]] || return 0

        if [[ "${#words[@]}" -eq 2 ]]; then
            _files -/
        elif [[ "${words[-1]}" == '' ]] && [[ "${words[-2]}" != "${__zoxide_z_prefix}"?* ]]; then
            \builtin local result
            # shellcheck disable=SC2086,SC2312
            if result="$(\command zoxide query --exclude "$(__zoxide_pwd)" --interactive -- ${words[2,-1]})"; then
                result="${__zoxide_z_prefix}${result}"
                # shellcheck disable=SC2296
                compadd -Q "${(q-)result}"
            fi
            \builtin printf '\e[5n'
        fi
        return 0
    }

    \builtin bindkey '\e[0n' 'reset-prompt'
    [[ "${+functions[compdef]}" -ne 0 ]] && \compdef __zoxide_z_complete __zoxide_z
fi

# =============================================================================
#
# Commands for zoxide. Disable these using --no-cmd.
#

\builtin alias z=__zoxide_z
\builtin alias zi=__zoxide_zi

# =============================================================================
#
# To initialize zoxide, add this to your configuration (usually ~/.zshrc):
#
# eval "$(zoxide init zsh)"

# pnpm
export PNPM_HOME="/home/ed/.local/share/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end

# Added by LM Studio CLI (lms)
export PATH="$PATH:/home/ed/.lmstudio/bin"
# End of LM Studio CLI section


autoload -U +X bashcompinit && bashcompinit
complete -o nospace -C /home/linuxbrew/.linuxbrew/Cellar/terraform/1.13.5/bin/terraform terraform

# ---------------------------------------------------------------------------------
#Custom functions
cat(){
        command cat "$@" | less
}

pdf(){
        local filename=$(fzf)
        if [[ -z "$filename" ]]; then
                return 1
        fi
        command nohup firefox $filename > /dev/null 2>&1 &
}

d() {
    local dirname root

    if [[ $# -eq 0 ]]; then
      root=""
      dirname=$(fzf --walker dir --preview 'ls -a {}')
    else
      root="$1"
      dirname=$(fzf --walker dir --preview 'ls -a {}' --walker-root="$root")
    fi

    if [[ -z "$dirname" ]]; then
        return 0
    fi

    builtin cd "$dirname"
    command ls
}

function y() {
  local tmp=$(mktemp -t "yazi-cwd.XXXXXX")
  yazi "$@" --cwd-file="$tmp"
  local cwd
  cwd=$(cat "$tmp")
  rm -f -- "$tmp"
  if [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]
  then
    builtin cd "$cwd"
  fi
}

lmstudio(){nohup lmstudio --no-sandbox > /dev/null 2>&1 &}

mygh='git@github.com:kinlaten/'

gc() {
    git commit $@ 
}

weather() {
  curl "http://wttr.in/$1"
}

psf(){
  ps -eo comm | awk '!seen[$0]++' |fzf
}

killf(){
  local process
  process=$(ps -eo comm | awk '!seen[$0]++'|fzf)
  
  if [[ -z $process ]]; then return 0; fi

  command killall $process
}

#indexer children of current directory
indexf(){
  local files file i=1
  files=$(fzf --multi)

  if [[ -z $files ]]; then 
    echo "No file selected. Exitting"
    return 0; 
  fi

  while read -r file; do
    local new_name="$(printf '%02d' $i)-$(basename "$file")"

  mv -v "$file" "$new_name"
  i=$((i+1))
done<<<"$files"
}

sysf() {
    local service action status_output status_key

    service=$(systemctl list-units --type=service --plain --all | awk '{print $1}' | fzf)
    if [[ -z "$service" ]]; then return 0; fi

    status_output=$(sudo systemctl status "$service")

    status_key=$(printf "%s" "$status_output" | fzf --prompt="--- Status of $service --- Press ENTER to continue or Q to quit" --expect=enter,q --no-sort)

    if [[ "$status_key" == q* ]]; then
        echo "Bye"
        return 0 # Exit the function cleanly
    fi

    action=$(printf "restart\nstop\nstart\nreload\nenable\ndisable" | fzf --prompt="Action on $service: ")

    if [[ -n "$action" ]]; then
        sudo systemctl "$action" "$service"
    fi
}

mf(){
    man -k .|fzf|awk '{print $2 " " $1}'|tr -d '()'|xargs man
}
# Add these lines to your ~/.bashrc or ~/.zshrc file

hisfc() {
    local target_command temp_file edited_command

    temp_file=$(mktemp)

    history -n -1000 | fzf > "$temp_file"
   
    if [[ ! -s "$temp_file" ]]; then
      rm -f "$temp_file"
      return 0
    fi

    command vi "$temp_file"
    command cat "$temp_file" | zsh
    command rm "$temp_file"
}

hisclip(){
  history -n -1000 | fzf | xclip -sel clip
}
